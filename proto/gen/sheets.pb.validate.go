// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: sheets.proto

package corev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Sheet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Sheet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sheet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SheetMultiError, or nil if none found.
func (m *Sheet) ValidateAll() error {
	return m.validate(true)
}

func (m *Sheet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for HostUserId

	if all {
		switch v := interface{}(m.GetDeliveryFee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SheetValidationError{
					field:  "DeliveryFee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SheetValidationError{
					field:  "DeliveryFee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryFee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SheetValidationError{
				field:  "DeliveryFee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Discount

	// no validation rules for ActiveMenuId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SheetValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SheetValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SheetValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SheetValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SheetValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SheetValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SheetMultiError(errors)
	}

	return nil
}

// SheetMultiError is an error wrapping multiple validation errors returned by
// Sheet.ValidateAll() if the designated constraints aren't met.
type SheetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SheetMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SheetMultiError) AllErrors() []error { return m }

// SheetValidationError is the validation error returned by Sheet.Validate if
// the designated constraints aren't met.
type SheetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SheetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SheetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SheetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SheetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SheetValidationError) ErrorName() string { return "SheetValidationError" }

// Error satisfies the builtin error interface
func (e SheetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSheet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SheetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SheetValidationError{}

// Validate checks the field values on SheetMember with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SheetMember) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SheetMember with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SheetMemberMultiError, or
// nil if none found.
func (m *SheetMember) ValidateAll() error {
	return m.validate(true)
}

func (m *SheetMember) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for SheetId

	if all {
		switch v := interface{}(m.GetJoinedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SheetMemberValidationError{
					field:  "JoinedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SheetMemberValidationError{
					field:  "JoinedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJoinedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SheetMemberValidationError{
				field:  "JoinedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SheetMemberMultiError(errors)
	}

	return nil
}

// SheetMemberMultiError is an error wrapping multiple validation errors
// returned by SheetMember.ValidateAll() if the designated constraints aren't met.
type SheetMemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SheetMemberMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SheetMemberMultiError) AllErrors() []error { return m }

// SheetMemberValidationError is the validation error returned by
// SheetMember.Validate if the designated constraints aren't met.
type SheetMemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SheetMemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SheetMemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SheetMemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SheetMemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SheetMemberValidationError) ErrorName() string { return "SheetMemberValidationError" }

// Error satisfies the builtin error interface
func (e SheetMemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSheetMember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SheetMemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SheetMemberValidationError{}

// Validate checks the field values on ListSheetsFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListSheetsFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSheetsFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSheetsFilterMultiError, or nil if none found.
func (m *ListSheetsFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSheetsFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerUserId

	// no validation rules for NameQuery

	if len(errors) > 0 {
		return ListSheetsFilterMultiError(errors)
	}

	return nil
}

// ListSheetsFilterMultiError is an error wrapping multiple validation errors
// returned by ListSheetsFilter.ValidateAll() if the designated constraints
// aren't met.
type ListSheetsFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSheetsFilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSheetsFilterMultiError) AllErrors() []error { return m }

// ListSheetsFilterValidationError is the validation error returned by
// ListSheetsFilter.Validate if the designated constraints aren't met.
type ListSheetsFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSheetsFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSheetsFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSheetsFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSheetsFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSheetsFilterValidationError) ErrorName() string { return "ListSheetsFilterValidationError" }

// Error satisfies the builtin error interface
func (e ListSheetsFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSheetsFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSheetsFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSheetsFilterValidationError{}

// Validate checks the field values on CreateSheetReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateSheetReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSheetReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateSheetReqMultiError,
// or nil if none found.
func (m *CreateSheetReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSheetReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetIdempotencyKey()) < 1 {
		err := CreateSheetReqValidationError{
			field:  "IdempotencyKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CreateSheetReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDescription()) > 1000 {
		err := CreateSheetReqValidationError{
			field:  "Description",
			reason: "value length must be at most 1000 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetHostUserId()) < 1 {
		err := CreateSheetReqValidationError{
			field:  "HostUserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDeliveryFee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSheetReqValidationError{
					field:  "DeliveryFee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSheetReqValidationError{
					field:  "DeliveryFee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryFee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSheetReqValidationError{
				field:  "DeliveryFee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetDiscount() < 0 {
		err := CreateSheetReqValidationError{
			field:  "Discount",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateSheetReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateSheetReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateSheetReqValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateSheetReqMultiError(errors)
	}

	return nil
}

// CreateSheetReqMultiError is an error wrapping multiple validation errors
// returned by CreateSheetReq.ValidateAll() if the designated constraints
// aren't met.
type CreateSheetReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSheetReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSheetReqMultiError) AllErrors() []error { return m }

// CreateSheetReqValidationError is the validation error returned by
// CreateSheetReq.Validate if the designated constraints aren't met.
type CreateSheetReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSheetReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSheetReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSheetReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSheetReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSheetReqValidationError) ErrorName() string { return "CreateSheetReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateSheetReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSheetReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSheetReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSheetReqValidationError{}

// Validate checks the field values on CreateSheetResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateSheetResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSheetResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSheetRespMultiError, or nil if none found.
func (m *CreateSheetResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSheetResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSheet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSheetRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSheetRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSheet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSheetRespValidationError{
				field:  "Sheet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSheetRespMultiError(errors)
	}

	return nil
}

// CreateSheetRespMultiError is an error wrapping multiple validation errors
// returned by CreateSheetResp.ValidateAll() if the designated constraints
// aren't met.
type CreateSheetRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSheetRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSheetRespMultiError) AllErrors() []error { return m }

// CreateSheetRespValidationError is the validation error returned by
// CreateSheetResp.Validate if the designated constraints aren't met.
type CreateSheetRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSheetRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSheetRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSheetRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSheetRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSheetRespValidationError) ErrorName() string { return "CreateSheetRespValidationError" }

// Error satisfies the builtin error interface
func (e CreateSheetRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSheetResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSheetRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSheetRespValidationError{}

// Validate checks the field values on GetSheetReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetSheetReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSheetReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetSheetReqMultiError, or
// nil if none found.
func (m *GetSheetReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSheetReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetSheetReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSheetReqMultiError(errors)
	}

	return nil
}

// GetSheetReqMultiError is an error wrapping multiple validation errors
// returned by GetSheetReq.ValidateAll() if the designated constraints aren't met.
type GetSheetReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSheetReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSheetReqMultiError) AllErrors() []error { return m }

// GetSheetReqValidationError is the validation error returned by
// GetSheetReq.Validate if the designated constraints aren't met.
type GetSheetReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSheetReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSheetReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSheetReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSheetReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSheetReqValidationError) ErrorName() string { return "GetSheetReqValidationError" }

// Error satisfies the builtin error interface
func (e GetSheetReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSheetReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSheetReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSheetReqValidationError{}

// Validate checks the field values on GetSheetResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetSheetResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSheetResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetSheetRespMultiError, or
// nil if none found.
func (m *GetSheetResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSheetResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSheet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSheetRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSheetRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSheet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSheetRespValidationError{
				field:  "Sheet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSheetRespMultiError(errors)
	}

	return nil
}

// GetSheetRespMultiError is an error wrapping multiple validation errors
// returned by GetSheetResp.ValidateAll() if the designated constraints aren't met.
type GetSheetRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSheetRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSheetRespMultiError) AllErrors() []error { return m }

// GetSheetRespValidationError is the validation error returned by
// GetSheetResp.Validate if the designated constraints aren't met.
type GetSheetRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSheetRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSheetRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSheetRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSheetRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSheetRespValidationError) ErrorName() string { return "GetSheetRespValidationError" }

// Error satisfies the builtin error interface
func (e GetSheetRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSheetResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSheetRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSheetRespValidationError{}

// Validate checks the field values on UpdateSheetReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateSheetReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSheetReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateSheetReqMultiError,
// or nil if none found.
func (m *UpdateSheetReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSheetReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateSheetReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Name != nil {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 255 {
			err := UpdateSheetReqValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Description != nil {

		if utf8.RuneCountInString(m.GetDescription()) > 1000 {
			err := UpdateSheetReqValidationError{
				field:  "Description",
				reason: "value length must be at most 1000 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.ActiveMenuId != nil {
		// no validation rules for ActiveMenuId
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if len(errors) > 0 {
		return UpdateSheetReqMultiError(errors)
	}

	return nil
}

// UpdateSheetReqMultiError is an error wrapping multiple validation errors
// returned by UpdateSheetReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateSheetReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSheetReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSheetReqMultiError) AllErrors() []error { return m }

// UpdateSheetReqValidationError is the validation error returned by
// UpdateSheetReq.Validate if the designated constraints aren't met.
type UpdateSheetReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSheetReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSheetReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSheetReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSheetReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSheetReqValidationError) ErrorName() string { return "UpdateSheetReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateSheetReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSheetReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSheetReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSheetReqValidationError{}

// Validate checks the field values on UpdateSheetResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateSheetResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSheetResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSheetRespMultiError, or nil if none found.
func (m *UpdateSheetResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSheetResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSheet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSheetRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSheetRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSheet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSheetRespValidationError{
				field:  "Sheet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSheetRespMultiError(errors)
	}

	return nil
}

// UpdateSheetRespMultiError is an error wrapping multiple validation errors
// returned by UpdateSheetResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateSheetRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSheetRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSheetRespMultiError) AllErrors() []error { return m }

// UpdateSheetRespValidationError is the validation error returned by
// UpdateSheetResp.Validate if the designated constraints aren't met.
type UpdateSheetRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSheetRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSheetRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSheetRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSheetRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSheetRespValidationError) ErrorName() string { return "UpdateSheetRespValidationError" }

// Error satisfies the builtin error interface
func (e UpdateSheetRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSheetResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSheetRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSheetRespValidationError{}

// Validate checks the field values on ListSheetsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListSheetsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSheetsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListSheetsReqMultiError, or
// nil if none found.
func (m *ListSheetsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSheetsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListSheetsReqValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSheetsReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSheetsReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSheetsReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSheetsReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSheetsReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSheetsReqValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListSheetsReqMultiError(errors)
	}

	return nil
}

// ListSheetsReqMultiError is an error wrapping multiple validation errors
// returned by ListSheetsReq.ValidateAll() if the designated constraints
// aren't met.
type ListSheetsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSheetsReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSheetsReqMultiError) AllErrors() []error { return m }

// ListSheetsReqValidationError is the validation error returned by
// ListSheetsReq.Validate if the designated constraints aren't met.
type ListSheetsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSheetsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSheetsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSheetsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSheetsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSheetsReqValidationError) ErrorName() string { return "ListSheetsReqValidationError" }

// Error satisfies the builtin error interface
func (e ListSheetsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSheetsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSheetsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSheetsReqValidationError{}

// Validate checks the field values on ListSheetsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListSheetsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSheetsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListSheetsRespMultiError,
// or nil if none found.
func (m *ListSheetsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSheetsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSheets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSheetsRespValidationError{
						field:  fmt.Sprintf("Sheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSheetsRespValidationError{
						field:  fmt.Sprintf("Sheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSheetsRespValidationError{
					field:  fmt.Sprintf("Sheets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextCursor != nil {

		if all {
			switch v := interface{}(m.GetNextCursor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSheetsRespValidationError{
						field:  "NextCursor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSheetsRespValidationError{
						field:  "NextCursor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNextCursor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSheetsRespValidationError{
					field:  "NextCursor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSheetsRespMultiError(errors)
	}

	return nil
}

// ListSheetsRespMultiError is an error wrapping multiple validation errors
// returned by ListSheetsResp.ValidateAll() if the designated constraints
// aren't met.
type ListSheetsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSheetsRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSheetsRespMultiError) AllErrors() []error { return m }

// ListSheetsRespValidationError is the validation error returned by
// ListSheetsResp.Validate if the designated constraints aren't met.
type ListSheetsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSheetsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSheetsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSheetsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSheetsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSheetsRespValidationError) ErrorName() string { return "ListSheetsRespValidationError" }

// Error satisfies the builtin error interface
func (e ListSheetsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSheetsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSheetsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSheetsRespValidationError{}

// Validate checks the field values on JoinSheetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *JoinSheetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JoinSheetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// JoinSheetRequestMultiError, or nil if none found.
func (m *JoinSheetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *JoinSheetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetIdempotencyKey()) < 1 {
		err := JoinSheetRequestValidationError{
			field:  "IdempotencyKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := JoinSheetRequestValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserId()) < 1 {
		err := JoinSheetRequestValidationError{
			field:  "UserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return JoinSheetRequestMultiError(errors)
	}

	return nil
}

// JoinSheetRequestMultiError is an error wrapping multiple validation errors
// returned by JoinSheetRequest.ValidateAll() if the designated constraints
// aren't met.
type JoinSheetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JoinSheetRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JoinSheetRequestMultiError) AllErrors() []error { return m }

// JoinSheetRequestValidationError is the validation error returned by
// JoinSheetRequest.Validate if the designated constraints aren't met.
type JoinSheetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JoinSheetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JoinSheetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JoinSheetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JoinSheetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JoinSheetRequestValidationError) ErrorName() string { return "JoinSheetRequestValidationError" }

// Error satisfies the builtin error interface
func (e JoinSheetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJoinSheetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JoinSheetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JoinSheetRequestValidationError{}

// Validate checks the field values on JoinSheetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *JoinSheetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JoinSheetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// JoinSheetResponseMultiError, or nil if none found.
func (m *JoinSheetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *JoinSheetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMember()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JoinSheetResponseValidationError{
					field:  "Member",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JoinSheetResponseValidationError{
					field:  "Member",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMember()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JoinSheetResponseValidationError{
				field:  "Member",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JoinSheetResponseMultiError(errors)
	}

	return nil
}

// JoinSheetResponseMultiError is an error wrapping multiple validation errors
// returned by JoinSheetResponse.ValidateAll() if the designated constraints
// aren't met.
type JoinSheetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JoinSheetResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JoinSheetResponseMultiError) AllErrors() []error { return m }

// JoinSheetResponseValidationError is the validation error returned by
// JoinSheetResponse.Validate if the designated constraints aren't met.
type JoinSheetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JoinSheetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JoinSheetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JoinSheetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JoinSheetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JoinSheetResponseValidationError) ErrorName() string {
	return "JoinSheetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e JoinSheetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJoinSheetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JoinSheetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JoinSheetResponseValidationError{}

// Validate checks the field values on RemoveMemberRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveMemberRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveMemberRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveMemberRequestMultiError, or nil if none found.
func (m *RemoveMemberRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveMemberRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := RemoveMemberRequestValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserId()) < 1 {
		err := RemoveMemberRequestValidationError{
			field:  "UserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveMemberRequestMultiError(errors)
	}

	return nil
}

// RemoveMemberRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveMemberRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveMemberRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveMemberRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveMemberRequestMultiError) AllErrors() []error { return m }

// RemoveMemberRequestValidationError is the validation error returned by
// RemoveMemberRequest.Validate if the designated constraints aren't met.
type RemoveMemberRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveMemberRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveMemberRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveMemberRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveMemberRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveMemberRequestValidationError) ErrorName() string {
	return "RemoveMemberRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveMemberRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveMemberRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveMemberRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveMemberRequestValidationError{}

// Validate checks the field values on RemoveMemberResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveMemberResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveMemberResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveMemberResponseMultiError, or nil if none found.
func (m *RemoveMemberResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveMemberResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RemoveMemberResponseMultiError(errors)
	}

	return nil
}

// RemoveMemberResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveMemberResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveMemberResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveMemberResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveMemberResponseMultiError) AllErrors() []error { return m }

// RemoveMemberResponseValidationError is the validation error returned by
// RemoveMemberResponse.Validate if the designated constraints aren't met.
type RemoveMemberResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveMemberResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveMemberResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveMemberResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveMemberResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveMemberResponseValidationError) ErrorName() string {
	return "RemoveMemberResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveMemberResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveMemberResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveMemberResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveMemberResponseValidationError{}

// Validate checks the field values on ListMembersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMembersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMembersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMembersRequestMultiError, or nil if none found.
func (m *ListMembersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMembersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := ListMembersRequestValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListMembersRequestValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMembersRequestValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMembersRequestValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMembersRequestValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListMembersRequestMultiError(errors)
	}

	return nil
}

// ListMembersRequestMultiError is an error wrapping multiple validation errors
// returned by ListMembersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListMembersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMembersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMembersRequestMultiError) AllErrors() []error { return m }

// ListMembersRequestValidationError is the validation error returned by
// ListMembersRequest.Validate if the designated constraints aren't met.
type ListMembersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMembersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMembersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMembersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMembersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMembersRequestValidationError) ErrorName() string {
	return "ListMembersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMembersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMembersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMembersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMembersRequestValidationError{}

// Validate checks the field values on ListMembersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMembersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMembersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMembersResponseMultiError, or nil if none found.
func (m *ListMembersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMembersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMembersResponseValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMembersResponseValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMembersResponseValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextCursor != nil {

		if all {
			switch v := interface{}(m.GetNextCursor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMembersResponseValidationError{
						field:  "NextCursor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMembersResponseValidationError{
						field:  "NextCursor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNextCursor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMembersResponseValidationError{
					field:  "NextCursor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMembersResponseMultiError(errors)
	}

	return nil
}

// ListMembersResponseMultiError is an error wrapping multiple validation
// errors returned by ListMembersResponse.ValidateAll() if the designated
// constraints aren't met.
type ListMembersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMembersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMembersResponseMultiError) AllErrors() []error { return m }

// ListMembersResponseValidationError is the validation error returned by
// ListMembersResponse.Validate if the designated constraints aren't met.
type ListMembersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMembersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMembersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMembersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMembersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMembersResponseValidationError) ErrorName() string {
	return "ListMembersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMembersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMembersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMembersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMembersResponseValidationError{}

// Validate checks the field values on MenuItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuItemMultiError, or nil
// if none found.
func (m *MenuItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := MenuItemValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) < 1 {
		err := MenuItemValidationError{
			field:  "Title",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuItemValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuItemValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuItemValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetDescription()) > 1000 {
		err := MenuItemValidationError{
			field:  "Description",
			reason: "value length must be at most 1000 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Available

	for idx, item := range m.GetOptionGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuItemValidationError{
						field:  fmt.Sprintf("OptionGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuItemValidationError{
						field:  fmt.Sprintf("OptionGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuItemValidationError{
					field:  fmt.Sprintf("OptionGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuItemMultiError(errors)
	}

	return nil
}

// MenuItemMultiError is an error wrapping multiple validation errors returned
// by MenuItem.ValidateAll() if the designated constraints aren't met.
type MenuItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuItemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuItemMultiError) AllErrors() []error { return m }

// MenuItemValidationError is the validation error returned by
// MenuItem.Validate if the designated constraints aren't met.
type MenuItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuItemValidationError) ErrorName() string { return "MenuItemValidationError" }

// Error satisfies the builtin error interface
func (e MenuItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuItemValidationError{}

// Validate checks the field values on MenuOptionGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MenuOptionGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuOptionGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MenuOptionGroupMultiError, or nil if none found.
func (m *MenuOptionGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuOptionGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := MenuOptionGroupValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) < 1 {
		err := MenuOptionGroupValidationError{
			field:  "Title",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Required

	// no validation rules for MultiSelect

	// no validation rules for MinSelect

	// no validation rules for MaxSelect

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuOptionGroupValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuOptionGroupValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuOptionGroupValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuOptionGroupMultiError(errors)
	}

	return nil
}

// MenuOptionGroupMultiError is an error wrapping multiple validation errors
// returned by MenuOptionGroup.ValidateAll() if the designated constraints
// aren't met.
type MenuOptionGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuOptionGroupMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuOptionGroupMultiError) AllErrors() []error { return m }

// MenuOptionGroupValidationError is the validation error returned by
// MenuOptionGroup.Validate if the designated constraints aren't met.
type MenuOptionGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuOptionGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuOptionGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuOptionGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuOptionGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuOptionGroupValidationError) ErrorName() string { return "MenuOptionGroupValidationError" }

// Error satisfies the builtin error interface
func (e MenuOptionGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuOptionGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuOptionGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuOptionGroupValidationError{}

// Validate checks the field values on MenuOption with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuOption with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuOptionMultiError, or
// nil if none found.
func (m *MenuOption) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := MenuOptionValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) < 1 {
		err := MenuOptionValidationError{
			field:  "Title",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPriceDelta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuOptionValidationError{
					field:  "PriceDelta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuOptionValidationError{
					field:  "PriceDelta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceDelta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuOptionValidationError{
				field:  "PriceDelta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetMaxQuantity() < 1 {
		err := MenuOptionValidationError{
			field:  "MaxQuantity",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Available

	if len(errors) > 0 {
		return MenuOptionMultiError(errors)
	}

	return nil
}

// MenuOptionMultiError is an error wrapping multiple validation errors
// returned by MenuOption.ValidateAll() if the designated constraints aren't met.
type MenuOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuOptionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuOptionMultiError) AllErrors() []error { return m }

// MenuOptionValidationError is the validation error returned by
// MenuOption.Validate if the designated constraints aren't met.
type MenuOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuOptionValidationError) ErrorName() string { return "MenuOptionValidationError" }

// Error satisfies the builtin error interface
func (e MenuOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuOptionValidationError{}

// Validate checks the field values on AttachMenuWithPayloadReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachMenuWithPayloadReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachMenuWithPayloadReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachMenuWithPayloadReqMultiError, or nil if none found.
func (m *AttachMenuWithPayloadReq) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachMenuWithPayloadReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetIdempotencyKey()) < 1 {
		err := AttachMenuWithPayloadReqValidationError{
			field:  "IdempotencyKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := AttachMenuWithPayloadReqValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetItems()) < 1 {
		err := AttachMenuWithPayloadReqValidationError{
			field:  "Items",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AttachMenuWithPayloadReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AttachMenuWithPayloadReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AttachMenuWithPayloadReqValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AttachMenuWithPayloadReqMultiError(errors)
	}

	return nil
}

// AttachMenuWithPayloadReqMultiError is an error wrapping multiple validation
// errors returned by AttachMenuWithPayloadReq.ValidateAll() if the designated
// constraints aren't met.
type AttachMenuWithPayloadReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachMenuWithPayloadReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachMenuWithPayloadReqMultiError) AllErrors() []error { return m }

// AttachMenuWithPayloadReqValidationError is the validation error returned by
// AttachMenuWithPayloadReq.Validate if the designated constraints aren't met.
type AttachMenuWithPayloadReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachMenuWithPayloadReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachMenuWithPayloadReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachMenuWithPayloadReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachMenuWithPayloadReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachMenuWithPayloadReqValidationError) ErrorName() string {
	return "AttachMenuWithPayloadReqValidationError"
}

// Error satisfies the builtin error interface
func (e AttachMenuWithPayloadReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachMenuWithPayloadReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachMenuWithPayloadReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachMenuWithPayloadReqValidationError{}

// Validate checks the field values on AttachMenuWithPayloadResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AttachMenuWithPayloadResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttachMenuWithPayloadResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AttachMenuWithPayloadRespMultiError, or nil if none found.
func (m *AttachMenuWithPayloadResp) ValidateAll() error {
	return m.validate(true)
}

func (m *AttachMenuWithPayloadResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AttachMenuWithPayloadRespValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AttachMenuWithPayloadRespValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AttachMenuWithPayloadRespValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSheet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AttachMenuWithPayloadRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AttachMenuWithPayloadRespValidationError{
					field:  "Sheet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSheet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AttachMenuWithPayloadRespValidationError{
				field:  "Sheet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AttachMenuWithPayloadRespMultiError(errors)
	}

	return nil
}

// AttachMenuWithPayloadRespMultiError is an error wrapping multiple validation
// errors returned by AttachMenuWithPayloadResp.ValidateAll() if the
// designated constraints aren't met.
type AttachMenuWithPayloadRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachMenuWithPayloadRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachMenuWithPayloadRespMultiError) AllErrors() []error { return m }

// AttachMenuWithPayloadRespValidationError is the validation error returned by
// AttachMenuWithPayloadResp.Validate if the designated constraints aren't met.
type AttachMenuWithPayloadRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachMenuWithPayloadRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachMenuWithPayloadRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachMenuWithPayloadRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachMenuWithPayloadRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachMenuWithPayloadRespValidationError) ErrorName() string {
	return "AttachMenuWithPayloadRespValidationError"
}

// Error satisfies the builtin error interface
func (e AttachMenuWithPayloadRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachMenuWithPayloadResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachMenuWithPayloadRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachMenuWithPayloadRespValidationError{}

// Validate checks the field values on GetMenuReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMenuReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMenuReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMenuReqMultiError, or
// nil if none found.
func (m *GetMenuReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMenuReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := GetMenuReqValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMenuReqMultiError(errors)
	}

	return nil
}

// GetMenuReqMultiError is an error wrapping multiple validation errors
// returned by GetMenuReq.ValidateAll() if the designated constraints aren't met.
type GetMenuReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMenuReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMenuReqMultiError) AllErrors() []error { return m }

// GetMenuReqValidationError is the validation error returned by
// GetMenuReq.Validate if the designated constraints aren't met.
type GetMenuReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMenuReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMenuReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMenuReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMenuReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMenuReqValidationError) ErrorName() string { return "GetMenuReqValidationError" }

// Error satisfies the builtin error interface
func (e GetMenuReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMenuReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMenuReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMenuReqValidationError{}

// Validate checks the field values on GetMenuResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMenuResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMenuResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMenuRespMultiError, or
// nil if none found.
func (m *GetMenuResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMenuResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMenuRespValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMenuRespValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMenuRespValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMenuRespMultiError(errors)
	}

	return nil
}

// GetMenuRespMultiError is an error wrapping multiple validation errors
// returned by GetMenuResp.ValidateAll() if the designated constraints aren't met.
type GetMenuRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMenuRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMenuRespMultiError) AllErrors() []error { return m }

// GetMenuRespValidationError is the validation error returned by
// GetMenuResp.Validate if the designated constraints aren't met.
type GetMenuRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMenuRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMenuRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMenuRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMenuRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMenuRespValidationError) ErrorName() string { return "GetMenuRespValidationError" }

// Error satisfies the builtin error interface
func (e GetMenuRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMenuResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMenuRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMenuRespValidationError{}
