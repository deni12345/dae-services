// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: orders.proto

package corev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on OrderLineOption with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrderLineOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderLineOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderLineOptionMultiError, or nil if none found.
func (m *OrderLineOption) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderLineOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GroupId

	// no validation rules for OptionId

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetPriceDelta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderLineOptionValidationError{
					field:  "PriceDelta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderLineOptionValidationError{
					field:  "PriceDelta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceDelta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderLineOptionValidationError{
				field:  "PriceDelta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if len(errors) > 0 {
		return OrderLineOptionMultiError(errors)
	}

	return nil
}

// OrderLineOptionMultiError is an error wrapping multiple validation errors
// returned by OrderLineOption.ValidateAll() if the designated constraints
// aren't met.
type OrderLineOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderLineOptionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderLineOptionMultiError) AllErrors() []error { return m }

// OrderLineOptionValidationError is the validation error returned by
// OrderLineOption.Validate if the designated constraints aren't met.
type OrderLineOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderLineOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderLineOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderLineOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderLineOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderLineOptionValidationError) ErrorName() string { return "OrderLineOptionValidationError" }

// Error satisfies the builtin error interface
func (e OrderLineOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderLineOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderLineOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderLineOptionValidationError{}

// Validate checks the field values on OrderLine with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderLineMultiError, or nil
// if none found.
func (m *OrderLine) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MenuItemId

	// no validation rules for Name

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetOrderBasePrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderLineValidationError{
					field:  "OrderBasePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderLineValidationError{
					field:  "OrderBasePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderBasePrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderLineValidationError{
				field:  "OrderBasePrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOrderOptionsTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderLineValidationError{
					field:  "OrderOptionsTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderLineValidationError{
					field:  "OrderOptionsTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderOptionsTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderLineValidationError{
				field:  "OrderOptionsTotal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOrderTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderLineValidationError{
					field:  "OrderTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderLineValidationError{
					field:  "OrderTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderLineValidationError{
				field:  "OrderTotal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderLineValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderLineValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderLineValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Note

	if len(errors) > 0 {
		return OrderLineMultiError(errors)
	}

	return nil
}

// OrderLineMultiError is an error wrapping multiple validation errors returned
// by OrderLine.ValidateAll() if the designated constraints aren't met.
type OrderLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderLineMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderLineMultiError) AllErrors() []error { return m }

// OrderLineValidationError is the validation error returned by
// OrderLine.Validate if the designated constraints aren't met.
type OrderLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderLineValidationError) ErrorName() string { return "OrderLineValidationError" }

// Error satisfies the builtin error interface
func (e OrderLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderLineValidationError{}

// Validate checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Order) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrderMultiError, or nil if none found.
func (m *Order) ValidateAll() error {
	return m.validate(true)
}

func (m *Order) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SheetId

	// no validation rules for UserId

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSubtotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "Subtotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "Subtotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubtotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderValidationError{
				field:  "Subtotal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderValidationError{
				field:  "Total",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Note

	if all {
		switch v := interface{}(m.GetCreateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderValidationError{
				field:  "CreateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderMultiError(errors)
	}

	return nil
}

// OrderMultiError is an error wrapping multiple validation errors returned by
// Order.ValidateAll() if the designated constraints aren't met.
type OrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderMultiError) AllErrors() []error { return m }

// OrderValidationError is the validation error returned by Order.Validate if
// the designated constraints aren't met.
type OrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderValidationError) ErrorName() string { return "OrderValidationError" }

// Error satisfies the builtin error interface
func (e OrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderValidationError{}

// Validate checks the field values on ListOrdersFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListOrdersFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOrdersFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOrdersFilterMultiError, or nil if none found.
func (m *ListOrdersFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOrdersFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := ListOrdersFilterValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserId()) < 1 {
		err := ListOrdersFilterValidationError{
			field:  "UserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSince()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOrdersFilterValidationError{
					field:  "Since",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOrdersFilterValidationError{
					field:  "Since",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSince()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOrdersFilterValidationError{
				field:  "Since",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListOrdersFilterMultiError(errors)
	}

	return nil
}

// ListOrdersFilterMultiError is an error wrapping multiple validation errors
// returned by ListOrdersFilter.ValidateAll() if the designated constraints
// aren't met.
type ListOrdersFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOrdersFilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOrdersFilterMultiError) AllErrors() []error { return m }

// ListOrdersFilterValidationError is the validation error returned by
// ListOrdersFilter.Validate if the designated constraints aren't met.
type ListOrdersFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOrdersFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOrdersFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOrdersFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOrdersFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOrdersFilterValidationError) ErrorName() string { return "ListOrdersFilterValidationError" }

// Error satisfies the builtin error interface
func (e ListOrdersFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOrdersFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOrdersFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOrdersFilterValidationError{}

// Validate checks the field values on OrderLineOptionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderLineOptionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderLineOptionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderLineOptionReqMultiError, or nil if none found.
func (m *OrderLineOptionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderLineOptionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetGroupId()) < 1 {
		err := OrderLineOptionReqValidationError{
			field:  "GroupId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOptionId()) < 1 {
		err := OrderLineOptionReqValidationError{
			field:  "OptionId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetQuantity() <= 0 {
		err := OrderLineOptionReqValidationError{
			field:  "Quantity",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OrderLineOptionReqMultiError(errors)
	}

	return nil
}

// OrderLineOptionReqMultiError is an error wrapping multiple validation errors
// returned by OrderLineOptionReq.ValidateAll() if the designated constraints
// aren't met.
type OrderLineOptionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderLineOptionReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderLineOptionReqMultiError) AllErrors() []error { return m }

// OrderLineOptionReqValidationError is the validation error returned by
// OrderLineOptionReq.Validate if the designated constraints aren't met.
type OrderLineOptionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderLineOptionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderLineOptionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderLineOptionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderLineOptionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderLineOptionReqValidationError) ErrorName() string {
	return "OrderLineOptionReqValidationError"
}

// Error satisfies the builtin error interface
func (e OrderLineOptionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderLineOptionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderLineOptionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderLineOptionReqValidationError{}

// Validate checks the field values on OrderLineReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderLineReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderLineReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderLineReqMultiError, or
// nil if none found.
func (m *OrderLineReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderLineReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetMenuItemId()) < 1 {
		err := OrderLineReqValidationError{
			field:  "MenuItemId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetQuantity() <= 0 {
		err := OrderLineReqValidationError{
			field:  "Quantity",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderLineReqValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderLineReqValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderLineReqValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if utf8.RuneCountInString(m.GetNote()) > 500 {
		err := OrderLineReqValidationError{
			field:  "Note",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OrderLineReqMultiError(errors)
	}

	return nil
}

// OrderLineReqMultiError is an error wrapping multiple validation errors
// returned by OrderLineReq.ValidateAll() if the designated constraints aren't met.
type OrderLineReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderLineReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderLineReqMultiError) AllErrors() []error { return m }

// OrderLineReqValidationError is the validation error returned by
// OrderLineReq.Validate if the designated constraints aren't met.
type OrderLineReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderLineReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderLineReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderLineReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderLineReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderLineReqValidationError) ErrorName() string { return "OrderLineReqValidationError" }

// Error satisfies the builtin error interface
func (e OrderLineReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderLineReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderLineReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderLineReqValidationError{}

// Validate checks the field values on CreateOrderReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateOrderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrderReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateOrderReqMultiError,
// or nil if none found.
func (m *CreateOrderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetIdempotencyKey()) < 1 {
		err := CreateOrderReqValidationError{
			field:  "IdempotencyKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSheetId()) < 1 {
		err := CreateOrderReqValidationError{
			field:  "SheetId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLines()) < 1 {
		err := CreateOrderReqValidationError{
			field:  "Lines",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateOrderReqValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateOrderReqValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateOrderReqValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if utf8.RuneCountInString(m.GetUserId()) < 1 {
		err := CreateOrderReqValidationError{
			field:  "UserId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNote()) > 500 {
		err := CreateOrderReqValidationError{
			field:  "Note",
			reason: "value length must be at most 500 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateOrderReqMultiError(errors)
	}

	return nil
}

// CreateOrderReqMultiError is an error wrapping multiple validation errors
// returned by CreateOrderReq.ValidateAll() if the designated constraints
// aren't met.
type CreateOrderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrderReqMultiError) AllErrors() []error { return m }

// CreateOrderReqValidationError is the validation error returned by
// CreateOrderReq.Validate if the designated constraints aren't met.
type CreateOrderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrderReqValidationError) ErrorName() string { return "CreateOrderReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateOrderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrderReqValidationError{}

// Validate checks the field values on CreateOrderResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateOrderResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrderResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrderRespMultiError, or nil if none found.
func (m *CreateOrderResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrderResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrderRespValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrderRespValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrderRespValidationError{
				field:  "Order",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrderRespMultiError(errors)
	}

	return nil
}

// CreateOrderRespMultiError is an error wrapping multiple validation errors
// returned by CreateOrderResp.ValidateAll() if the designated constraints
// aren't met.
type CreateOrderRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrderRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrderRespMultiError) AllErrors() []error { return m }

// CreateOrderRespValidationError is the validation error returned by
// CreateOrderResp.Validate if the designated constraints aren't met.
type CreateOrderRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrderRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrderRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrderRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrderRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrderRespValidationError) ErrorName() string { return "CreateOrderRespValidationError" }

// Error satisfies the builtin error interface
func (e CreateOrderRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrderResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrderRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrderRespValidationError{}

// Validate checks the field values on UpdateOrderReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateOrderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOrderReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateOrderReqMultiError,
// or nil if none found.
func (m *UpdateOrderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOrderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateOrderReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLines()) < 1 {
		err := UpdateOrderReqValidationError{
			field:  "Lines",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateOrderReqValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateOrderReqValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateOrderReqValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Note != nil {

		if utf8.RuneCountInString(m.GetNote()) > 500 {
			err := UpdateOrderReqValidationError{
				field:  "Note",
				reason: "value length must be at most 500 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateOrderReqMultiError(errors)
	}

	return nil
}

// UpdateOrderReqMultiError is an error wrapping multiple validation errors
// returned by UpdateOrderReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateOrderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOrderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOrderReqMultiError) AllErrors() []error { return m }

// UpdateOrderReqValidationError is the validation error returned by
// UpdateOrderReq.Validate if the designated constraints aren't met.
type UpdateOrderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOrderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOrderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOrderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOrderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOrderReqValidationError) ErrorName() string { return "UpdateOrderReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateOrderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOrderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOrderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOrderReqValidationError{}

// Validate checks the field values on UpdateOrderResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateOrderResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateOrderResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateOrderRespMultiError, or nil if none found.
func (m *UpdateOrderResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateOrderResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateOrderRespValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateOrderRespValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateOrderRespValidationError{
				field:  "Order",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateOrderRespMultiError(errors)
	}

	return nil
}

// UpdateOrderRespMultiError is an error wrapping multiple validation errors
// returned by UpdateOrderResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateOrderRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateOrderRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateOrderRespMultiError) AllErrors() []error { return m }

// UpdateOrderRespValidationError is the validation error returned by
// UpdateOrderResp.Validate if the designated constraints aren't met.
type UpdateOrderRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateOrderRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateOrderRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateOrderRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateOrderRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateOrderRespValidationError) ErrorName() string { return "UpdateOrderRespValidationError" }

// Error satisfies the builtin error interface
func (e UpdateOrderRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateOrderResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateOrderRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateOrderRespValidationError{}

// Validate checks the field values on GetOrderReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOrderReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetOrderReqMultiError, or
// nil if none found.
func (m *GetOrderReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetOrderReqValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetOrderReqMultiError(errors)
	}

	return nil
}

// GetOrderReqMultiError is an error wrapping multiple validation errors
// returned by GetOrderReq.ValidateAll() if the designated constraints aren't met.
type GetOrderReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderReqMultiError) AllErrors() []error { return m }

// GetOrderReqValidationError is the validation error returned by
// GetOrderReq.Validate if the designated constraints aren't met.
type GetOrderReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderReqValidationError) ErrorName() string { return "GetOrderReqValidationError" }

// Error satisfies the builtin error interface
func (e GetOrderReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderReqValidationError{}

// Validate checks the field values on GetOrderResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetOrderResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetOrderRespMultiError, or
// nil if none found.
func (m *GetOrderResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOrder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderRespValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderRespValidationError{
					field:  "Order",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderRespValidationError{
				field:  "Order",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOrderRespMultiError(errors)
	}

	return nil
}

// GetOrderRespMultiError is an error wrapping multiple validation errors
// returned by GetOrderResp.ValidateAll() if the designated constraints aren't met.
type GetOrderRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderRespMultiError) AllErrors() []error { return m }

// GetOrderRespValidationError is the validation error returned by
// GetOrderResp.Validate if the designated constraints aren't met.
type GetOrderRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderRespValidationError) ErrorName() string { return "GetOrderRespValidationError" }

// Error satisfies the builtin error interface
func (e GetOrderRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderRespValidationError{}

// Validate checks the field values on ListOrdersReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListOrdersReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOrdersReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListOrdersReqMultiError, or
// nil if none found.
func (m *ListOrdersReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOrdersReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetPageSize(); val < 1 || val > 100 {
		err := ListOrdersReqValidationError{
			field:  "PageSize",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOrdersReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOrdersReqValidationError{
					field:  "Cursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOrdersReqValidationError{
				field:  "Cursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOrdersReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOrdersReqValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOrdersReqValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListOrdersReqMultiError(errors)
	}

	return nil
}

// ListOrdersReqMultiError is an error wrapping multiple validation errors
// returned by ListOrdersReq.ValidateAll() if the designated constraints
// aren't met.
type ListOrdersReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOrdersReqMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOrdersReqMultiError) AllErrors() []error { return m }

// ListOrdersReqValidationError is the validation error returned by
// ListOrdersReq.Validate if the designated constraints aren't met.
type ListOrdersReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOrdersReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOrdersReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOrdersReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOrdersReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOrdersReqValidationError) ErrorName() string { return "ListOrdersReqValidationError" }

// Error satisfies the builtin error interface
func (e ListOrdersReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOrdersReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOrdersReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOrdersReqValidationError{}

// Validate checks the field values on ListOrdersResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListOrdersResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOrdersResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListOrdersRespMultiError,
// or nil if none found.
func (m *ListOrdersResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOrdersResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOrdersRespValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOrdersRespValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOrdersRespValidationError{
					field:  fmt.Sprintf("Orders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextCursor != nil {

		if all {
			switch v := interface{}(m.GetNextCursor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOrdersRespValidationError{
						field:  "NextCursor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOrdersRespValidationError{
						field:  "NextCursor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNextCursor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOrdersRespValidationError{
					field:  "NextCursor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListOrdersRespMultiError(errors)
	}

	return nil
}

// ListOrdersRespMultiError is an error wrapping multiple validation errors
// returned by ListOrdersResp.ValidateAll() if the designated constraints
// aren't met.
type ListOrdersRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOrdersRespMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOrdersRespMultiError) AllErrors() []error { return m }

// ListOrdersRespValidationError is the validation error returned by
// ListOrdersResp.Validate if the designated constraints aren't met.
type ListOrdersRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOrdersRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOrdersRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOrdersRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOrdersRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOrdersRespValidationError) ErrorName() string { return "ListOrdersRespValidationError" }

// Error satisfies the builtin error interface
func (e ListOrdersRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOrdersResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOrdersRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOrdersRespValidationError{}
